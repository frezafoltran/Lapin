{%extends "algos/question_base.html"%}
{%import 'bootstrap/wtf.html' as wtf%}

{%block back_to%}
        <a href="{{url_for('main.algos_trees_and_graphs', q_num=0)}}" >Back to Trees and Graphs</a>
{%endblock%}

{%block question_name%}
    Subtree of Tree
{%endblock%}

{%block question_explanation%}
    Write an algorithm to find if a smaller binary tree is part of a larger binary tree.
{%endblock%}


{%block question_source%}

{%endblock%}

{%block code_application%}
<p>This algorithm is useful to plot binary trees without repeating nodes.
    A generalized version of this algorithm is used in the
    <a href="{{url_for('main.algos_trees_and_graphs', q_num=3)}}">Employee Hierarchy</a> example.
    Below, we demonstrate this idea to simplify, whenever possible, the plotting of binary trees.</p>

<button onclick="newTree()">Refresh</button>
<br>
<br>

<div class="container row" id="canvas_div"></div>

<div class="row" id="arrow" style="display:none;"><img style="width:30px;heigth:40px;" src="{{url_for('static', filename='images/down_arrow.png')}}"></div>

<div class="container row" id="result_div"></div>

{%endblock%}

{%block code_intuition%}
 <p>The idea is simply to look for the root node of the smaller tree in the larger one. When we find, we check
 if their children are equal. Else, we continue looking for another occurrence of the root.</p>
{%endblock%}

{%block code_digest%}
<p><span class="step">Step 1</span> As <span class="code">pre-order</span> traversal is usually implemented through
recursion, we will write a recursive function to traverse the tree. We include <span class="code">level</span>
as one of the inputs to keep track of the level we are at.</p>
    <section>
        <div class="code-lines">
            <script src="https://gist.github.com/frezafoltran/175b5628a2fdbe108f8cd68019313119.js"></script>
        </div>
    </section>

<p><span class="step">Step 2</span> An important part of the recursive function is to identify whether
or not we are at a new level. If we are at an unvisited level, we crate a new <span class="code">list</span>
linked list that will later be added to the array of linked lists called lists. Else, we simply access the respective
level at the <span class="code">lists</span> array.</p>
    <section>
        <div class="code-lines">
            <script src="https://gist.github.com/frezafoltran/bf9c0bc21bc8fab36cf6f36f5c6dfce3.js"></script>
        </div>
    </section>

<p><span class="step">Step 3</span> We wrap the recursive function for ease of use.</p>
    <section>
        <div class="code-lines">
            <script src="https://gist.github.com/frezafoltran/2e9121c41386319f10ed94dac8f45c2f.js"></script>
        </div>
    </section>



{%endblock%}

{%block code_complexity%}
<p>The time complexity is the same as usual traversals of binary trees, O(n), where n is the number of nodes.
The space complexity is also O(n) to store the linked lists.</p>
{%endblock%}


{%block full_code_gist%}
    <script src="https://gist.github.com/frezafoltran/4f9326027dcff4cfbdf4860b97892f19.js"></script>
{%endblock%}




{%block scripts%}
    {{super()}}
    {{moment.include_moment()}}
    {{moment.lang(g.locale)}}

    <script>


        var Node = function (data){
            this.data = data;
            this.left = null;
            this.right = null;
        }

        var names = ['Ringo', 'John', 'Alfred', 'Angela', 'Julia',
                    'Jude', 'Yolanda', 'Trevor', 'Catarina', 'Sofia',
                    'Potato', 'Pedro', 'Fiona', 'Cyrus', 'Olivia'];


        function getXPos(numNodes, middle){

            //var middle = c.width/2;
            if (numNodes == 1){

                return [middle];
            }

            var out = [];
            var middles = [];

            for (var i = 0; i < numNodes/2; i ++){

                var coeff = (2*i+1)/(numNodes/2)
                middles.push(coeff * middle);
            }

            for (var k = 0; k < middles.length; k ++){

                    var offSet = middles[0]/Math.pow(2, (1));
                    out.push(middles[k] - offSet);
                    out.push(middles[k] + offSet);
                }

            return out;

        }

        function connectCircles(x1, y1, x2, y2, radius, c){

            var ctx = c.getContext("2d");
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            var startX = x1;
            var startY = y1 + radius;
            var endX = x2;
            var endY = y2 - radius;

            if (x1 == x2){

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                return;

            }

            var slope = (y2 - y1)/(x2 - x1);

            startX = x1 + radius / Math.sqrt(1 + Math.pow(slope, 2));
            startY = slope * startX + (y1 - x1 * slope);

            if (startX > x2){
                startX = x1 - radius / Math.sqrt(1 + Math.pow(slope, 2));
                startY = slope * startX + (y1 - x1 * slope);
            }

            endX = x2 + radius / Math.sqrt(1 + Math.pow(slope, 2));
            endY = slope * endX + (y1 - x1 * slope);

            if (endX > x1){
                endX = x2 - radius / Math.sqrt(1 + Math.pow(slope, 2));
                endY = slope * endX + (y1 - x1 * slope);
            }


            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
        }

        function findParent(possibleParents, j, numNodes){

            var cur = numNodes;
            var parent = possibleParents;
            var offset = 0;
            var rightChild = j % 2 == 0 ? false : true;

            while (cur > 2){
                cur = cur / 2;

                if (j < cur + offset){
                    parent = parent.slice(0, parent.length/2);

                }
                else{
                    offset += parent.length;
                    parent = parent.slice(parent.length/2, parent.length);
                }
            }

            parent = parent[0];
            return [parent, rightChild];

        }

        function createCanvas(numLayers, c){

            var rad = 25;

            if (numLayers == 2){
                c.width = rad * 6;
                c.height = rad * 5;
            }
            else if (numLayers == 3){
                c.width = rad * 12;
                c.height = rad * 7;
            }
            else if (numLayers == 4){
                c.width = rad * 24;
                c.height = rad * 9;
            }

            c.style.display = 'inline';
            var ctx = c.getContext("2d");


            var nameCounter = 0;

            //store coordinates to draw line between them
            var nodesCoord = {};
            var curParents = [];

            for (var i = 0; i < numLayers; i ++){

                var yOffset = (2 * i + 1)*(rad + 1);
                var numNodes = Math.pow(2, i);

                var currXPos = getXPos(numNodes, c.width/2);
                curParents.push([]);


                for (var j = 0; j < numNodes; j ++){

                    //not add some nodes in last row
                    if (i == numLayers - 1 && Math.random() > 0.5){
                        nameCounter ++;
                        continue;
                    }

                    ctx.beginPath();
                    ctx.font = (rad/2).toString() + "px Georgia";
                    ctx.fillText(names[nameCounter], currXPos[j] - 0.8*rad, yOffset + 0.2*rad);
                    ctx.arc(currXPos[j], yOffset, rad, 0, 2 * Math.PI);
                    ctx.stroke();

                    var node = new Node(names[nameCounter]);
                    curParents[i].push(node);
                    nodesCoord[names[nameCounter]] = [currXPos[j], yOffset];

                    if (i == 0){
                        var root = node;
                    }
                    if (i > 0){
                        [parent, rightChild] = findParent(curParents[i-1], j, numNodes);

                        if (rightChild){
                            parent.right = node;
                        }
                        else{
                            parent.left = node;
                        }

                        connectCircles(nodesCoord[parent.data][0], nodesCoord[parent.data][1],
                            nodesCoord[node.data][0], nodesCoord[node.data][1], rad, c);

                    }

                    nameCounter ++;

                }
            }

            return root;
        }

        function containsTree(n1, n2){

            if (!n2){
                return true;
            }
            return subTree(n1, n2);
        }

        function subTree(r1, r2){

            if (!r1){
                return false;
            }
            else if (r1.data == r2.data && matchTree(r1, r2)){
                return true;
            }
            return subTree (r1.left, r2) || subTree (r1.right, r2);
        }

        function matchTree(r1, r2){

            if (!r1 && !r2){
                return true;
            }
            else if (!r1 || !r2){
                return false;
            }
            else if (r1.data != r2.data){
                return false;
            }
            else{
                return matchTree(r1.left, r2.left) && matchTree(r1.right, r2.right);
            }
        }

        function cloneCanvas(oldCanvas) {

            //create a new canvas
            var newCanvas = document.createElement('canvas');
            var context = newCanvas.getContext('2d');

            //set dimensions
            newCanvas.width = oldCanvas.width;
            newCanvas.height = oldCanvas.height;

            //apply the old canvas to the new one
            context.drawImage(oldCanvas, 0, 0);

            //return the new canvas
            return newCanvas;
        }

        function preOrder(root, treeStr){

            if (!root){
                treeStr.push(0);
                return null;
            }
            //console.log(root.data);
            treeStr.push(root.data);
            preOrder(root.left, treeStr);
            preOrder(root.right, treeStr);

        }

        function isContained(array1, array2){
            //check if array1 is contained in array2
            if (array1.length > array2.length){
                return false;
            }

            //can subtract array1.length from array2.length for the upper bound
            for (var i = 0; i < array2.length; i ++){

                if (array1[0] == array2[i]){
                    flag = true;
                    for (var j = i; j < array1.length + i; j ++){

                        if (array1[j - i] != 0 && array1[j - i] != array2[j]){
                            flag = false;
                            break;
                        }
                    }
                    if (flag == true){
                        return true;
                    }

                }
            }

            return false;
        }


        function newTree(){

            console.clear();

            names = ['Ringo', 'John', 'Alfred', 'Angela', 'Julia',
                    'Jude', 'Yolanda', 'Trevor', 'Catarina', 'Sofia',
                    'Potato', 'Pedro', 'Fiona', 'Cyrus', 'Olivia'];

            var div = document.getElementById('canvas_div');
            div.innerHTML = '';

            var numLayers = [2, 3, 4];
            var canvases = [];
            var roots = [];

            names.sort(() => Math.random() - 0.5);
            for (var i = numLayers.length - 1; i >= 0; i --){
                var c = document.createElement('canvas');

                //make sure we have subtrees more often
                if (i == numLayers.length - 2){
                    var rand = Math.random();
                    if (rand <= 0.5){
                        names = names.slice(2, 3).concat(names.slice(5, 7)).concat(names.slice(11, names.length));
                    }
                    else{
                        names = names.slice(1,2).concat(names.slice(3, 5)).concat(names.slice(7, 11));
                    }

                }

                if (i == numLayers.length - 3){
                    if (names.length == 7){
                        var rand = Math.random();
                        if (rand <= 0.5){
                            names = names.slice(1, 2).concat(names.slice(3, 5));
                        }
                        else{
                            names = names.slice(2, 3).concat(names.slice(5, names.length));
                        }

                    }
                    else{
                        names.sort(() => Math.random() - 0.5);
                    }
                }


                var root = createCanvas(numLayers[i], c);
                roots.push(root);
                canvases.push(c);
            }

            for (var i = numLayers.length - 1; i >= 0; i --){

                var col = document.createElement('div');
                col.class = 'col';
                c = canvases[i];
                div.appendChild(col.appendChild(c));
            }

            //check if they trees can be combined into less pieces
            var oneInThree = containsTree(roots[0], roots[2]);
            var oneInTwo =  containsTree(roots[1], roots[2]);
            var twoInThree = containsTree(roots[0], roots[1]);

            console.log(oneInThree);
            console.log(oneInTwo);
            console.log(twoInThree);

            //console.log('---');
            var treeStr1 = [];
            preOrder(roots[0],  treeStr1);
            console.log(treeStr1);
            var treeStr2 = [];
            preOrder(roots[1], treeStr2);
            console.log(treeStr2);
            //console.log('---');
            var treeStr3 = [];
            preOrder(roots[2], treeStr3);
            console.log(treeStr3);

            var oneInThree = isContained(treeStr3, treeStr1);
            var oneInTwo = isContained(treeStr3, treeStr2);
            var twoInThree = isContained(treeStr2, treeStr1);

            console.log(oneInThree);
            console.log(oneInTwo);
            console.log(twoInThree);


            var resultDiv = document.getElementById('result_div');
            resultDiv.innerHTML = '';

            var resultCol = document.createElement('div');
            resultCol.class = 'col';
            var resultCol2 = document.createElement('div');
            resultCol2.class = 'col';

            if (!oneInThree && !oneInTwo && !twoInThree){

                document.getElementById('arrow').style.display = 'none';

                var p = document.createElement('p');
                p.innerHTML = 'Not possible to simplify display.';
                resultDiv.appendChild(p);
            }

            else{

                document.getElementById('arrow').style.display = 'inline';

                if (twoInThree && oneInTwo){
                    resultDiv.appendChild(resultCol.appendChild(cloneCanvas(canvases[0])));
                }
                else if (twoInThree){
                     resultDiv.appendChild(resultCol.appendChild(cloneCanvas(canvases[2])));
                     resultDiv.appendChild(resultCol2.appendChild(cloneCanvas(canvases[0])));
                }
                else if (oneInThree){
                     resultDiv.appendChild(resultCol.appendChild(cloneCanvas(canvases[1])));
                     resultDiv.appendChild(resultCol2.appendChild(cloneCanvas(canvases[0])));
                }
                else if (oneInTwo){
                     resultDiv.appendChild(resultCol.appendChild(cloneCanvas(canvases[1])));
                     resultDiv.appendChild(resultCol.appendChild(cloneCanvas(canvases[0])));
                }


            }



        }

        newTree();



    </script>

{%endblock%}